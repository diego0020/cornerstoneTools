import external from './../../externalModules.js';

const state = {
  structureSetData = [
    {
      name: 'default',
      uid: 'DEFAULT_STRUCTURE_SET',
      locked = false,
      ROIContours: [],
      activeROIContourIndex: 0
    }
  ];

  activeStructureSetIndex = 0;
};

const getters = {
  ROIContourInfo (structureSetUid, ROIContourUid) {
    if (!structureSetUid || !ROIContourUid) {
      throw new Error(
        'Insufficient information provided, must provide structureSetUid and ROI ContourUid'
      );
    }

    const structureSet = structureSetData.some((element) => {
      return element.uid === structureSetUid;
    });

    if (!structureSet) {
      return;
    }

    const ROIContour = structureSet.ROIContours.some((element) => {
      return element.uid === ROIContourUid;
    });

    if (!ROIContour) {
      return;
    }

    return {
      ROIContourName: ROIContour.name,
      structureSetName: structureSet.name,
      color: roiColors.color
    };
  },
  activeROIContourIndex: () => {
    return state.structureSetData[activeStructureSetIndex].activeROIContourIndex;
  }
};

const setters = {
  activeStructureSetIndex: (index) => {
    if (index < 0 || index >= store.structureSetData.length) {
      throw new Error(
        'Index is out of bounds.'
      );
    }

    state.activeStructureSetIndex = index;
  },
  activeROIContourIndex: (index) => {
    const activeStructureSet = store.structureSetData[store.activeStructureSetIndex];
    const ROIContours = activeStructureSet.ROIContours;

    if (index < 0 || index >= ROIContours.length) {
      throw new Error(
        'Index is out of bounds.'
      );
    }

    activeStructureSet.activeROIContourIndex = index;
  },

  /**
   * addStructureSetData - Adds a new structureSet to the store. A structureSet
   * refers to a collection of 3D ROIs that typically reference the same scan.
   *
   * @param {string} name                 The name of your collection of ROIContours.
   * @param {string} [uid]                The UID of the collection of ROIContours.
   *                                      Autogenerate if undefined.
   * @param {string} [referencedSeriesInstanceUid] The UID of the series that
   *                                      the structureSet references.
   *                                      Omit from entry if not present.
   * @param {boolean} [locked]             Whether the structureSet is read only.
   */
  addStructureSetData: function (
    name,
    uid,
    referencedSeriesInstanceUid,
    locked = false
  ) {
    if (!name) {
      throw new Error(
        'name is undefined, cannot add structureSet.'
      );
    }

    if (!uid) {
      uid = generateUID();
    }

    const structureSet = {
      name,
      uid,
      locked,
      activeROIContourIndex: 0,
      ROIContours : []
    };

    if (referencedSeriesInstanceUid) {
      structureSet.referencedSeriesInstanceUid = referencedSeriesInstanceUid;
    }

    state.structureSetData.push(structureSet);
  },

  /**
   * addVolumeToStructureSet - Adds a new volume to the structureSet.
   *
   * @param  {string} name    The name of the ROI.
   * @param  {string} [structureSetUid] The UID of the structureSet, if absent,
   *                                    defaults to the active structureSet.
   * @param  {string} [uid]   The UID of the ROI. Autogenerated if undefined.
   * @param  {string} [color] A CSS recognised color with which to render
   *                          the ROI contour. Autogenerated if undefined.
   * @param  {boolean} [active] Whether the ROIContour should be set active for
   *                            this structureSet.
   * @return {number}         The index the ROI that was inserted.
   */
  addROIToStructureSetAndGetIndex: function (
    name,
    structureSetUid,
    uid,
    color,
    active = true
  ) {
    if (!name) {
      throw new Error(
        'name is undefined, cannot add structureSet.'
      );
    }

    if (!uid) {
      uid = generateUID();
    }

    if (!color) {
      color = getNextColor();
    }

    const structureSetData = state.structureSetData;

    // Find the structureSet.
    let structureSet;

    if (structureSetUid) {
      structureSet = structureSetData.some((element) => {
        return element.uid = structureSetUid
      });
    } else {
      structureSet = structureSetData[state.activeStructureSetIndex];
    }

    structureSet.ROIContours.push({
      name,
      uid,
      color
    });

    if (active) {
      // Set the current structureSet's activeROIContourIndex to the new index.
      structureSet.activeROIContourIndex = structureSet.ROIContours.length - 1;
    }
  }
};


/**
 * enabledElementCallback - Element specific initilisation.
 * @public
 * @param  {Object} enabledElement  The element on which the module is
 *                                  being initialised.
 */
function enabledElementCallback (enabledElement) {
  //
}

/**
 * onRegisterCallback - Initialise the module when a new element is added.
 * @public
 */
function onRegisterCallback () {
  //
}

export default {
  state,
  onRegisterCallback,
  enabledElementCallback,
  getters,
  setters
};

const roiColors = [
  'cornflowerblue',
  'firebrick',
  'goldenrod',
  'blueviolet',
  'indianred',
  'orange',
  'mediumturquoise',
  'lightcoral',
  'khaki',
  'darkmagenta',
  'lightseagreen',
  'tomato',
  'aquamarine',
  'darksalmon',
  'moccasin',
  'orchid',
  'skyblue',
  'peru'
];

// Such that first color will be the first in roiColors
let currentColorIndex = importColors.length;

/**
 * getNextColor - TODO
 *
 * @return {string} A CSS recognised color with which to render the ROI contour.
 */
function getNextColor () {
  currentColorIndex++;
  if (currentColorIndex >= importColors.length) {
    currentColorIndex = 0;
  }

  return importColors[currentColorIndex];
}

/**
* Generates a UUID for the enabledElement.
*
* @return {String} the UUID.
*/
function generateUID () { // https://stackoverflow.com/a/8809472/9208320 Public Domain/MIT
  /* eslint no-bitwise: ["error", { "allow": ["&","|"] }] */
  let d = new Date().getTime();
  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
    d += performance.now(); // Use high-precision timer if available
  }
  return 'x.x.x.x.x.x.xxxx.xxx.x.x.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    const r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
  });
}
